# 《深入理解 Java 虚拟机》读书笔记之第二章——Java内存区域与内存溢出异常

这一章的重点是介绍 **JVM 内存结构**和 **Java 对象模型**，注意这两个术语的区别，很容易搞混淆。对应书中的内容分别是“运行时数据区域”和“Hotspot虚拟机对象探秘”。

## JVM 内存结构

JVM 会将其所管理的内存划分为以下几个运行时数据区域，这一节的重点在于搞清楚每一个区域的用途。

![JVM内存结构.png](https://i.loli.net/2019/05/22/5ce4e7e89b81133814.png)

### 程序计数器（Program Counter Register）

程序计数器是一块非常小的内存空间，它是当前线程所执行的字节码的行号指示器。Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。因此，为了保证线程切换后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器（即“线程私有”）。

注意，如果当前线程执行的是一个 Java 方法，那么计数器记录的是正在执行的字节码指令地址；如果执行的是本地（Naive）方法，计数器值为空。

### Java 虚拟机栈（Java Virtual Machine Stacks）

同样，Java 虚拟机栈也是私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构），用于存储局部变量表、操作数栈、动态链接（？）、方法出口等信息。

### 本地方法栈（Naive Method Stack）

本地方法栈与 Java 虚拟机栈发挥的作用是很相似的，区别仅在于：虚拟机栈为虚拟机执行 Java 方法（即字节码）服务，而本地方法栈则为虚拟机使用的 Naive 方法服务。

### Java 堆（Java Heap）

对于大多数应用来说，Java 堆是 Java 虚拟机所管理的内存中最大的一块。要注意 Java 堆是被所有线程共享的一块内存区域，其在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存。因此，垃圾收集器管理的主要区域就是堆了，这一点我们后面在学习第三章时再详细讨论。

### 方法区（Method Area）

方法区与堆一样，也是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、变量、常量、静态变量、即时编译器编译后的代码等数据。

### 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分。class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期产生的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

### 直接内存（Direct Memory）

直接内存并不是 Java 虚拟机运行时数据区的一部分。

## Java 对象模型

### 对象的创建
这里讨论的对象只限于普通 Java 对象，不包括数组和 class 对象等。

首先，当虚拟机遇到一条 new 指令后，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就必须先执行相应的类加载过程（双亲委派机制）。

在**类加载检查**通过后，接下来就是为新生对象**分配内存**。对象所需的内存大小在类加载完成之后便可以确定。分配内存存在两种方式。当 Java 堆中的内存比较规整时，可以采用**指针碰撞**（Bump the Pointer）的方式，此时 Java 对象在堆中的地址是连续的。而当堆内存中已使用的内存和空闲的内存相互交错时，就必须采用**空闲列表**（Free List）的分配方式了。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又取决于所采用的垃圾收集器是否带有压缩整理功能决定。除此之外，还需要考虑**同步问题**，即在高并发下的线程安全。解决办法也有两种。一种是对分配内存空间的动作进行同步处理——采用 CAS 加上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间（称为本地线程分配缓冲 Thread Local Allocation Buffer，TLAB）之中。

这之后要将分配到的**内存空间初始化为零值**（不包括对象头）。然后就是**对象头（Object Header）的设置**。

在上面的工作都完成后，从虚拟机的角度来看，一个新的对象已经产生了。但是从 Java 程序的角度来看，对象才刚开始创建：<init>方法还没执行，所有字段还都为零。

### 对象的内存布局

分为三个区域：对象头、实例数据和对齐填充。

首先是对象头，其包括两个部分，一个是用于存储对象自身的运行时数据，比如哈希码、GC分代年龄、锁状态标志等，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。注意，如果对象是一个数组，那么对象头重还需要有记录数组长度的数据。

实例数据部分是对象真正存储的有效信息，也就是在程序代码中所定义的的各种类型的字段内容。

对齐填充并不是必须存在的。由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此对象的大小必须是8字节的整数倍。而对象头满足这个条件，只有当实例数据部分不满足时，才会需要对齐填充来补齐。

### 对象的访问定位

Java 程序通过栈上的 reference 数据来操作堆上的具体对象，但是具体的访问定位方式没有明确，目前主流的方法有两种。

1. 使用**句柄访问**，Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息。
2. 使用**直接指针访问**，Java 堆中对象的布局中必须考虑如何放置访问类型数据的相关信息。

![Java对象访问方式1.png](https://i.loli.net/2019/05/23/5ce607efb342d67247.png)

![Java对象访问方式2.png](https://i.loli.net/2019/05/23/5ce608139a91332602.png)

**比较**：使用句柄，reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时对象的移动时非常普遍的行为）时，只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针，访问速度很快，因为它节省了一次指针定位的时间开销。
