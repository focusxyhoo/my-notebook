---
title: 基础知识
tags: [Java]
created: '2019-03-29T01:06:29.119Z'
modified: '2019-04-02T06:19:19.464Z'
---

# 基础知识

## 面向对象的特征
**答**：
1. **抽象**。抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。
2. **封装**。封装保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。在面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装比传统语言的封装更为清晰、更为有力。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法才可以访问到这些成员变量，这就基本上实现对象的封装，就很容易找出要分配到这个类上的方法了，就基本上算是会面向对象的编程了。把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。
3. **继承**。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。
4. **多态**。多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。
在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

## Java中实现多态的机制
**答**：
靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。

## `&`和`&&`的区别
**答**：
1. 两者都可以用作**逻辑与（and）**的运算符。即，当运算符两边表达式的结果都为true时，整个运算结果才为true，否则结果为false。
2. 但是，`&&`还具有**短路**的功能。即，当运算符左边的表达式为false，右边的表达式不会被计算，因此也不会抛出异常。而`&`没有这个功能。
3. `&`还可以用作**位运算符**。当运算符两边的表达式不是`boolean`类型时，表示按位与操作。如：通常使用`0x0f`来与一个整数进行`&`运算，来获取该整数的最低4个bit位。

## `char`类型变量可以存储一个中文汉字么？
**答**：
`char`类型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以`char`型变量中当然可以存储汉字。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个`char`型变量中就不能存储这个特殊汉字。
补充说明：unicode编码占用两个字节，所以，`char`类型的变量也是占用两个字节。

## `==`操作符和`equals()`方法的区别
**答**：
1. `==`操作符专门用来判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）。
2. `equals()`方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，**它比较的两个对象是独立的**。记住，字符串的比较基本上都是使用`equals()`方法的。
3. 如果一个类没有自己定义`equals()`方法，那么它将继承`Object`类的`equals()`方法。从源码上可以看到，如果一个类没有自己定义`equals()`方法，它默认的`equals()`方法（从`Object`类继承的）就是使用`==`操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用`equals()`和使用`==`会得到同样的结果，如果比较的是两个独立的对象则总返回false。
4. 注意：尽量不要使用`username.equals("xyz")`，而采用`"xyz".equals(username)`的形式。因为变量`username`可能为null，会报空指针错误。

## hashCode()和equals()的关联
**答**：
**什么是hashCode()？**
hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）
**重点**

1. 如果两个对象相等，则其hashCode一定也是相同的。反之不一定相同。
2. 如果两个对象相等，则对其分别调用equals方法都返回true。
3. equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。
4. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

## 静态变量和实例变量的区别
**答**：
1. 语法定义上的区别：静态变量前要加`static`关键字，而实例变量不需要。
2. 程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

## 是否可以从一个`static`方法内部发起对非`static`方法的调用？
**答**：
不可以。因为非`static`方法是和对象相关联的，必须创建对象后，才能对该对象进行方法调用，而`static`方法直接通过类名调用。

## `Integer`和`int`的区别（包装类、自动封装）
**答**：
`int`是Java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，`Integer`是java为int提供的封装类。`int`的默认值为0，而`Integer`的默认值为null。即`Integer`可以区分出未赋值和值为0的区别，`int`则无法表达出未赋值的情况。
另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。

## `final`修饰变量时，是引用不能变，还是引用的对象不能变？
**答**：
使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。
```java
final StringBuffer a = new StringBuffer("immutable");
a = new StringBuffer("hello"); \\ 报错
a.append("world"); \\ 编译通过
```

## `Math`类中的三种取整方法
**答**：
`Math`类中有三种取整方法，分别是：`ceil()`、`floor()`和`ground()`。作用分别是向上取整、向下取整、四舍五入取整。其中，`Math.ground()`的实现方式是`Math.floor(x + 0.5)`。

## 作用域`public`、`protected`和`private`的区别
**答**：
如果修饰的元素前面没有写任何访问修饰符，则表示friendly。
| 作用域 | 当前类 | 同一package | 子类 | 其它package |
| :---: | :---: | :---: | :---: | :---: |
| public | 1 | 1 | 1 | 1 |
| protected | 1 | 1 | 1 | 0 |
| friendly | 1 | 1 | 0 | 0 |
| private | 1 | 0 | 0 | 0 |

## `overload`和`override`的区别
**答**：
`overload`是重载的意思，表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。要注意：
1. 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int,float)，但是不能为fun(int,int)）；
2. 不能通过访问权限、返回类型、抛出的异常进行重载；
3. 方法的异常类型和数目不会对重载造成影响；
4. 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。

`override`是覆盖、重写的意思，表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。常见的情况有，对接口的实现，以及子类覆盖父类中的方法。要注意：
1. 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
2. 覆盖的方法的返回值必须和被覆盖的方法的返回一致；
3. 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
4. 被覆盖的方法不能为`private`，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 

其它：
1. 构造器`constructor`不能被覆盖，但是可以重载。

## StringBuilder、StringBuffer和String的区别
**答**：
从三个方面进行叙述：
**可变性**
简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，`private　final　char　value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串`char[]value`，但是没有用final关键字修饰，所以这两种对象都是可变的。
StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。
**线程安全性**
String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。
**性能**
每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
**总结**：
1. 操作少量的数据，String 比较合适。
2. 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder。
3. 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer。

## 自动装箱和拆箱
**答**：
**装箱**：将基本类型用它们对应的引用类型包装起来；
**拆箱**：将包装类型转换为基本数据类型。

## 成员变量和局部变量的区别
**答**：
从以下几个方面进行回答：
**语法**
成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
**在内存中的存储方式**
如果成员变量被static修饰，那么这个成员变量是属于类的，存在于方法区（静态区）。如果没有被static修饰，则是属于对象的。对象存在于堆内存，而局部变量则存在于栈内存。
**在内存中的存在时间**
成员变量被看作是对象的一部分，随对象的创建而存在，而局部变量随着方法的调用而消失。
**自动赋初值**
成员变量如果没有赋初值，则会赋值为默认的类型初始值（例外：被final修饰的成员变量必须被显式赋值），而局部变量不会自动赋值。

## Java中只有值传递
**答**：
按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。

## transient关键字的总结
**答**：
transient关键字的作用是：
1. 阻止实例中那些用此关键字修饰的的变量序列化；
2. 当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。

transient只能修饰变量，不能修饰类和方法。

## 获取用键盘输入常用的两种方法
**答**：
1. 通过scanner
```java
Scanner input = new Scanner(System.in);
String s  = input.nextLine();
input.close();
```
2. 通过BufferReader
```java
BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); 
String s = input.readLine(); 
```
