# 线程安全
最近看到一篇写线程安全的文章，个人感觉写得非常好，深入浅出，很容易理解。恰好对线程安全的理解还不是很深入，因此就想根据这篇文章自己再写一遍，加深认识。

## 线程安全的定义
《论语》中有一句话，“学而优则仕”，很容易错误地理解为“学习好就可以做官”。实际上，这里的“优”，通“悠”，意思是，学习之余还有余力或者闲暇，就去做官（进一步推行仁义）。

这里讲这一段是想表明，线程安全并不是指线程的安全，而是指的内存的安全。在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。在没有保护机制的情况下，对于多线程来说，堆内存是不安全的。解决问题的方法有很多，下面慢慢道来。

## 局部变量
在程序中，操作系统会为每个线程分配属于其的内存空间，通常称为栈内存。这部分空间其他线程是无权访问的，由操作系统来保证。

因此我们首先想到的就是将需要保护的数据放到线程的栈内存中。较为常见就是局部变量了。比如下面这个方法中，变量`sum`、`count`、`avg`均为局部变量，它们都是分配在线程栈内存中。

```java
double avgSocre(double[] scores) {
    double sum = 0;
    for (double score: scores) {
        sum += score;
    }
    int count = scores.length;
    double avg = sum / count;
    return avg;
```

**对于局部变量，每个线程都会在其栈内存中复制一份。**因此无论有多少个线程访问上面这个方法，都是线程安全的，这些变量会在每一个线程的栈内存中都复制一遍，其他线程无法访问。

## ThreadLocal
通过局部变量确实能保证线程安全，但是局部变量的使用范围也因此被限制在这个方法中了，其他方法完全无权访问。而实际上有些数据我们希望是能够被多种方法访问的，因此我们需要采用其他方法。ThreadLocal类就为我们解决了这个痛点。

关于ThreadLocal类的实现方法，推荐去看一下源码，基本情况是这样的：Thread类有一个成员变量，类似于Map类型，专门用于存储ThreadLocal类型的数据。从逻辑从属关系来讲，这些ThreadLocal数据是属于Thread类的成员变量级别的。而从内存的角度来看，这些ThreadLocal数据是分配在堆内存中的。

这样，每一个线程都将ThreadLocal数据复制一份到自己的栈内存中，互不影响。

## 只读
通过将数据设置为常量或者只读数据也可以实现线程安全，因为不能修改，自然也就没有前面所说的风险了。

## 锁
现实中的情况相比前面三种方法要更为复杂。这个时候就需要**锁**这种机制来满足我们的要求了。即，当某个线程需要访问堆内存中的数据时，首先需要获取该数据的锁，只有获取到锁之后，才能进行操作，否则只能等待（或者去干其他事情），拿到锁的线程可以放心进行操作，因为在同一时间里，其他线程不能获取到锁，也就无法修改数据，获取到锁的线程完成其操作后，应该释放该锁，以便其他线程获取锁。这样就保证了数据的一致性。

## 乐观锁
一般来说，锁已经可以满足我们的实际需求了，那为什么这里还要有CAS（Compare and Swap）呢？这是因为锁的获取和释放是要花费一定代价的，尤其是当不需要考虑线程安全问题时，锁的存在会导致资源的浪费。这就是我们说的重量级锁。

针对这种情况，CAS就被提出来了。在并发很小的情况下，数据被意外修改的风险很低，但是这种风险又确实存在，在这种情况下就需要使用CAS了。

其实这里的CAS就是乐观锁，即以数据不会被意外修改的假设为前提，如果数据被修改了，就放弃之前的操作，从新再来。相对来说，悲观锁持悲观态度，认定数据一定会被修改，因此对所有操作都要加锁。

## 参考资料
1. [如果你这样回答“什么是线程安全”，面试官都会对你刮目相看](https://www.itcodemonkey.com/article/14529.html)
