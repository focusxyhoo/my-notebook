# 链表算法问题总结
## 分析
### 链表的分类
+ 单向链表
+ 双向链表
+ 循环链表

### 链表的基本操作
+ 插入
+ 删除
+ （分组）翻转
+ 排序 Partition、归并
+ 复制
+ 归并排序
+ 找环、起点、长度
+ （倒数）第 k 个节点
+ 随机返回一个节点
+ 和其他数据结构（二叉树）相互转换

## 详解
### 插入
+ 哪些指针需要修改？**前驱的 next，新节点的 next**
+ 需要找到插入之前的那个节点
+ 特殊情况：在 head 之前插入（包括 head == null 的情况）:

```
cur.next = head;
head = cur;
```
+ 一般情况：在 pre 后面插入:
 
```
cur.next = pre.next;
pre.next = cur;
```
### 删除
+ 哪些指针需要修改？**前驱的 next**
+ 需要找到删除之前的那个节点
+ 特殊情况：删除 head：

```
temp = head.next;
head = temp;
```
+ 一般情况：在 pre 后面删除：

```
temp = pre.next;
pre.next = temp.next;
```
### 思考
+ 双向链表的插入、删除
+ 循环有序链表的插入、删除（建议断开、再连上）
+ **懒删除**
    + 要删除 cur 这个节点（注意不是最后一个）
    + 把 cur 复制成 cur.next
    + 删除 cur.next

### 翻转
思路：把当前节点拿过来作为已经翻转结果的表头（类似堆栈）。

```java
ListNode result = null;
while (head) {
    ListNode temp = head.next; // 保存下一个节点
    head.next = result; // 当前节点放到结果的开头
    result = head; // 当前节点的头
    head = temp; // head 指向下一个节点
}
return result;
```
### 思考
+ 翻转部分链表（Leetcode 92）
    + 如何找到第 m 个和第 n 个元素
    + 如何处理前面和后面？
        + 保存前面部分的最后一个元素
        + 保存后面部分的第一个元素
        + 特殊情况？
+ 每 k 个元素翻转一次（Leetcode 25）
    + 前面翻转好的部分（小链表）
    + 要翻转的部分（k 个节点）
    + 后面没处理的部分（小链表）
    + 不足 k 个如何处理？

### 判断是否有环？环长度有多大？环的第一个节点？
见 Leetcode 141、142。
#### 方法一：用一个 set 存放每一个节点地址
设置一个 set 会增加空间复杂度，而 set 中的查找也会增加时间复杂度。当然用 Hash 可以避免查找带来的时间复杂度，但是空间复杂度不会因此减少。
#### 方法二：采用双指针
+ 用两个指针 p1 和 p2，p1 每次走一步，p2 每次走两步，如果有圈一定会相遇
+ 为什么一定会相遇？
+ 相遇时如何找交点？
+ 一些变量
    + 圈长 n
    + 起点到圈的起点的距离 a
    + p1 到圈起点时，p2 在圈中的位置 x (0<=x<n)
+ p1 到起点后，经过 n-x 步肯定相遇（追击问题）
+ 设相遇点到圈起点的距离是 b
+ p1 走的距离是 a+b
+ p2 走的距离是 a+b+kn = 2(a+b) => a+b = kn
+ 如何找到圈的起点？
    + 将 p1 拉回链表起点，p2 从相遇点继续走。a 步后（两个指针每次均走一步），p1 到圈起点，p2刚好也到圈起点。
+ 如何找圈长？
    + 相遇后，p2再走一圈并统计长度就是圈长。

### 单向链表找交点
见 Leetcode 160。类似 Y 字形。
#### 方法一
用一个 set 记录一个链表里的所有节点
#### 方法二
一个链表长度为 x，另一个链表长度为 y，假设 x >= y, 第一个链表的指针先走 x-y 步，然后再一起走，相遇的位置即为交点。
#### 方法三
将第一个链表首尾相连，练成一个环，这样就可以用找环起点的方法来解决问题。但是要注意，结束之后要记得恢复第一个链表的结果。实际上这种方法并不如第二种方法简单，应该首先用方法二。

### 单链表中除了 next 指针，还有一个 random 指针，随机指向任何一个其他元素。复制该链表。
见 Leetcode 138。
难点：我们不知道 random 指针在复制后链表中的地址。
#### 方法一
用一个 map 将每个节点的新地址和旧地址联系起来，先按普通办法复制链表，再两个链表同时走一遍，复制 random。
#### 方法二
+ 插入：每个旧节点后面插入一个自身的复制
+ 复制 random 指针
    + 一个旧节点 a 的复制是 a.next
    + a.random 的副本就是 a.random.next
    + 新节点的 random 指针就是 a.next.random = a.random.next（空值单独判断）
+ 拆分
    + 旧节点链表就是奇数项
    + 新节点链表就是偶数项

### 链表 partition
链表里存放整数，给定 x 把比 x 小的节点放到 >= x 之前。见 Leetcode 86。


## 总结
+ 注意
    + 哪些指针需要修改
    + 修改前需要保存（防止链表断掉）
    + 注意空指针
+ 特点：可以重新建立表头
    + 翻转
    + partition
    + 注意第一个元素以及表尾
