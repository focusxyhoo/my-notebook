# 解决hash冲突的方法

## 开放定址法

### 线性探测再散列

冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

### 二次探测再散列

冲突发生时，在表的左右进行跳跃式探测，比较灵活。

### 伪随机数探测再散列

具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。

## 拉链法（链地址法）

这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

也即Java中HashMap的实现方式。

## 再哈希法

这种方法是同时构造**多个不同**的哈希函数。这种方法不易产生聚集，但增加了计算时间。

## 建立公共溢区

这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

## 链地址法与开放定址法的比较

### 链地址法的优点

+ 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
+ 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
+ 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
+ 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

### 链地址法的缺点

指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。